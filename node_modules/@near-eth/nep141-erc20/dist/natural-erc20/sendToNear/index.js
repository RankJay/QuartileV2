"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkMint = exports.mint = exports.checkSync = exports.checkLock = exports.lock = exports.checkApprove = exports.approve = exports.initiate = exports.recover = exports.findAllTransfers = exports.findAllTransactions = exports.checkStatus = exports.act = exports.i18n = exports.TRANSFER_TYPE = exports.DESTINATION_NETWORK = exports.SOURCE_NETWORK = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const ethers_1 = require("ethers");
const client_1 = require("@near-eth/client");
const near_api_js_1 = require("near-api-js");
const i18nHelpers_1 = require("@near-eth/client/dist/i18nHelpers");
const status = __importStar(require("@near-eth/client/dist/statuses"));
const utils_1 = require("@near-eth/client/dist/utils");
const utils_2 = require("@near-eth/utils");
const find_replacement_tx_1 = require("find-replacement-tx");
const getMetadata_1 = require("../getMetadata");
exports.SOURCE_NETWORK = 'ethereum';
exports.DESTINATION_NETWORK = 'near';
exports.TRANSFER_TYPE = '@near-eth/nep141-erc20/natural-erc20/sendToNear';
const APPROVE = 'approve-natural-erc20-to-nep141';
const LOCK = 'lock-natural-erc20-to-nep141';
const SYNC = 'sync-natural-erc20-to-nep141';
const MINT = 'mint-natural-erc20-to-nep141';
const steps = [
    LOCK,
    SYNC,
    MINT
];
const transferDraft = {
    // Attributes common to all transfer types
    // amount,
    completedStep: null,
    // destinationTokenName,
    errors: [],
    // recipient,
    // sender,
    // sourceToken: erc20Address,
    // sourceTokenName,
    // decimals,
    status: status.ACTION_NEEDED,
    type: exports.TRANSFER_TYPE,
    // Cache eth tx information used for finding a replaced (speedup/cancel) tx.
    // ethCache: {
    //   from,                     // tx.from of last broadcasted eth tx
    //   to,                       // tx.to of last broadcasted eth tx (can be multisig contract)
    //   safeReorgHeight,          // Lower boundary for replacement tx search
    //   nonce                     // tx.nonce of last broadcasted eth tx
    // }
    // Attributes specific to natural-erc20-to-nep141 transfers
    completedConfirmations: 0,
    lockHashes: [],
    lockReceipts: [],
    neededConfirmations: 20,
    mintHashes: []
};
/* eslint-disable @typescript-eslint/restrict-template-expressions */
exports.i18n = {
    en_US: {
        steps: (transfer) => i18nHelpers_1.stepsFor(transfer, steps, {
            [LOCK]: `Start transfer of ${utils_1.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.sourceTokenName} to NEAR`,
            [SYNC]: `Wait for ${transfer.neededConfirmations + Number(utils_1.getBridgeParams().nearEventRelayerMargin)} transfer confirmations for security`,
            [MINT]: `Deposit ${utils_1.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.destinationTokenName} in NEAR`
        }),
        statusMessage: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Failed';
            if (transfer.status === status.ACTION_NEEDED) {
                switch (transfer.completedStep) {
                    case null: return 'Ready to transfer from Ethereum';
                    case APPROVE: return 'Ready to transfer from Ethereum'; // TODO: remove. This was only needed to prevent breaking user's ongoing transfer
                    case SYNC: return 'Ready to deposit in NEAR';
                    default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
                }
            }
            switch (transfer.completedStep) {
                case null: return 'Transfering to NEAR';
                case APPROVE: return 'Transfering to NEAR'; // TODO: remove. This was only needed to prevent breaking user's ongoing transfer
                case LOCK: return `Confirming transfer ${transfer.completedConfirmations + 1} of ${transfer.neededConfirmations + Number(utils_1.getBridgeParams().nearEventRelayerMargin)}`;
                case SYNC: return 'Depositing in NEAR';
                case MINT: return 'Transfer complete';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        },
        callToAction: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Retry';
            if (transfer.status !== status.ACTION_NEEDED)
                return null;
            switch (transfer.completedStep) {
                case null: return 'Transfer';
                case APPROVE: return 'Transfer'; // TODO: remove. This was only needed to prevent breaking user's ongoing transfer
                case SYNC: return 'Deposit';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        }
    }
};
/* eslint-enable @typescript-eslint/restrict-template-expressions */
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
async function act(transfer) {
    switch (transfer.completedStep) {
        case null: return await lock(transfer);
        case APPROVE: return await lock(transfer); // TODO: remove. This was only needed to prevent breaking user's ongoing transfer
        case LOCK: return await checkSync(transfer);
        case SYNC:
            try {
                return await mint(transfer);
            }
            catch (error) {
                console.error(error);
                if (error.message.includes('Failed to redirect to sign transaction')) {
                    // Increase time to redirect to wallet before recording an error
                    await new Promise(resolve => setTimeout(resolve, 10000));
                }
                if (typeof window !== 'undefined')
                    utils_2.urlParams.clear('minting');
                throw error;
            }
        default: throw new Error(`Don't know how to act on transfer: ${transfer.id}`);
    }
}
exports.act = act;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
async function checkStatus(transfer) {
    switch (transfer.completedStep) {
        case null: return await checkLock(transfer);
        case APPROVE: return await checkLock(transfer); // TODO: remove. This was only needed to prevent breaking user's ongoing transfer
        case LOCK: return await checkSync(transfer);
        case SYNC: return await checkMint(transfer);
        default: throw new Error(`Don't know how to checkStatus for transfer ${transfer.id}`);
    }
}
exports.checkStatus = checkStatus;
/**
 * Find all lock transactions sending `erc20Address` tokens to NEAR.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.erc20Address Token address.
 * @param params.options Optional arguments.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.erc20LockerAddress Rainbow bridge ERC-20 token locker address.
 * @param params.options.erc20LockerAbi Rainbow bridge ERC-20 token locker abi.
 * @returns Array of Ethereum transaction hashes.
 */
async function findAllTransactions({ fromBlock, toBlock, sender, erc20Address, options }) {
    var _a, _b, _c;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const ethTokenLocker = new ethers_1.ethers.Contract((_b = options.erc20LockerAddress) !== null && _b !== void 0 ? _b : bridgeParams.erc20LockerAddress, (_c = options.erc20LockerAbi) !== null && _c !== void 0 ? _c : bridgeParams.erc20LockerAbi, provider);
    const filter = ethTokenLocker.filters.Locked(erc20Address, sender);
    const events = await ethTokenLocker.queryFilter(filter, fromBlock, toBlock);
    return events.filter(event => !event.args.accountId.startsWith('aurora:')).map(event => event.transactionHash);
}
exports.findAllTransactions = findAllTransactions;
/**
 * Recover all transfers sending `erc20Address` tokens to Near.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.erc20Address Token address.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
async function findAllTransfers({ fromBlock, toBlock, sender, erc20Address, options }) {
    const lockTransactions = await findAllTransactions({ fromBlock, toBlock, sender, erc20Address, options });
    const transfers = await Promise.all(lockTransactions.map(async (tx) => await recover(tx, options)));
    return transfers;
}
exports.findAllTransfers = findAllTransfers;
/**
 * Recover transfer from a lock tx hash.
 * @param lockTxHash Ethereum transaction hash which initiated the transfer.
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
async function recover(lockTxHash, options) {
    var _a, _b, _c, _d, _e;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const receipt = await provider.getTransactionReceipt(lockTxHash);
    const ethTokenLocker = new ethers_1.ethers.Contract((_b = options.erc20LockerAddress) !== null && _b !== void 0 ? _b : bridgeParams.erc20LockerAddress, (_c = options.erc20LockerAbi) !== null && _c !== void 0 ? _c : bridgeParams.erc20LockerAbi, provider);
    const filter = ethTokenLocker.filters.Locked();
    const events = await ethTokenLocker.queryFilter(filter, receipt.blockNumber, receipt.blockNumber);
    const lockedEvent = events.find(event => event.transactionHash === lockTxHash);
    if (!lockedEvent) {
        throw new Error('Unable to process lock transaction event.');
    }
    const erc20Address = lockedEvent.args.token;
    const amount = lockedEvent.args.amount.toString();
    const recipient = lockedEvent.args.accountId;
    const sender = lockedEvent.args.sender;
    const symbol = (_d = options.symbol) !== null && _d !== void 0 ? _d : await getMetadata_1.getSymbol({ erc20Address, options });
    const sourceTokenName = symbol;
    const destinationTokenName = 'n' + symbol;
    const decimals = (_e = options.decimals) !== null && _e !== void 0 ? _e : await getMetadata_1.getDecimals({ erc20Address, options });
    const txBlock = await lockedEvent.getBlock();
    const transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date(txBlock.timestamp * 1000).toISOString(),
        amount,
        completedStep: LOCK,
        destinationTokenName,
        recipient,
        sender,
        sourceToken: erc20Address,
        sourceTokenName,
        symbol,
        decimals,
        status: status.IN_PROGRESS,
        lockHashes: [lockTxHash],
        lockReceipts: [receipt]
    };
    // Check transfer status
    return await checkSync(transfer, options);
}
exports.recover = recover;
/**
 * Initiate a transfer from Ethereum to NEAR by locking tokens.
 * Broadcasts the lock transaction and creates a transfer object.
 * The receipt will be fetched by checkStatus.
 * Allowance must be enough before tokens can be transfered.
 * Use `approve` to allow spending of ERC-20 tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.erc20Address ERC-20 address of token to transfer.
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient NEAR address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.symbol ERC-20 symbol (queried if not provided).
 * @param params.options.decimals ERC-20 decimals (queried if not provided).
 * @param params.options.sender Sender of tokens (defaults to the connected wallet address).
 * @param params.options.ethChainId Ethereum chain id of the bridge.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.erc20LockerAddress Rainbow bridge ERC-20 token locker address.
 * @param params.options.erc20LockerAbi Rainbow bridge ERC-20 token locker abi.
 * @param params.options.erc20Abi ERC-20 token abi.
 * @param params.options.signer Ethers signer to use.
 * @returns The created transfer object.
 */
async function initiate({ erc20Address, amount, recipient, options }) {
    var _a, _b, _c, _d, _e;
    options = options !== null && options !== void 0 ? options : {};
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getSignerProvider();
    const symbol = (_b = options.symbol) !== null && _b !== void 0 ? _b : await getMetadata_1.getSymbol({ erc20Address, options });
    const sourceTokenName = symbol;
    const destinationTokenName = 'n' + symbol;
    const decimals = (_c = options.decimals) !== null && _c !== void 0 ? _c : await getMetadata_1.getDecimals({ erc20Address, options });
    const signer = (_d = options.signer) !== null && _d !== void 0 ? _d : provider.getSigner();
    const sender = (_e = options.sender) !== null && _e !== void 0 ? _e : (await signer.getAddress()).toLowerCase();
    // various attributes stored as arrays, to keep history of retries
    let transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date().toISOString(),
        amount: amount.toString(),
        destinationTokenName,
        recipient,
        sender,
        sourceToken: erc20Address,
        sourceTokenName,
        symbol,
        decimals
    };
    transfer = await lock(transfer, options);
    if (typeof window !== 'undefined')
        transfer = await client_1.track(transfer);
    return transfer;
}
exports.initiate = initiate;
/**
 * Allow the bridge ERC-20 locker to transfer tokens from the user's address.
 * Allowance must be enough before tokens can be transfered with `initiate`
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.erc20Address ERC-20 address of token to transfer.
 * @param params.amount Number of tokens to transfer.
 * @param params.options Optional arguments.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.ethChainId Ethereum chain id of the bridge.
 * @param params.options.erc20LockerAddress Rainbow bridge ERC-20 token locker address.
 * @param params.options.erc20Abi ERC-20 token abi.
 * @returns ApprovalInfo object which is used by checkApprove to track the transaction.
 */
async function approve({ erc20Address, amount, options }) {
    var _a, _b, _c, _d, _e;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getSignerProvider();
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        // Webapp should prevent the user from confirming if the wrong network is selected
        throw new Error(`Wrong eth network for approve, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const safeReorgHeight = await provider.getBlockNumber() - 20;
    const erc20Contract = new ethers_1.ethers.Contract(erc20Address, (_c = options.erc20Abi) !== null && _c !== void 0 ? _c : bridgeParams.erc20Abi, (_d = options.signer) !== null && _d !== void 0 ? _d : provider.getSigner());
    const pendingApprovalTx = await erc20Contract.approve((_e = options.erc20LockerAddress) !== null && _e !== void 0 ? _e : bridgeParams.erc20LockerAddress, amount);
    return {
        ...transferDraft,
        amount: amount.toString(),
        sourceToken: erc20Address,
        ethCache: {
            from: pendingApprovalTx.from,
            to: pendingApprovalTx.to,
            safeReorgHeight,
            data: pendingApprovalTx.data,
            nonce: pendingApprovalTx.nonce
        },
        approvalHashes: [pendingApprovalTx.hash],
        approvalReceipts: [],
        status: status.IN_PROGRESS
    };
}
exports.approve = approve;
/**
 * Check the status of the `approve` transaction.
 * @param transfer Object returned by `approve` to check it's status
 * @param param.options Optional arguments.
 * @param param.options.provider Ethereum provider to use.
 * @param param.options.ethChainId Ethereum chain id of the bridge.
 */
async function checkApprove(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkApprove, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const approvalHash = last(transfer.approvalHashes);
    let approvalReceipt = await provider.getTransactionReceipt(approvalHash);
    // If no receipt, check that the transaction hasn't been replaced (speedup or canceled)
    if (!approvalReceipt) {
        // don't break old transfers in case they were made before this functionality is released
        if (!transfer.ethCache)
            return transfer;
        try {
            const tx = {
                nonce: transfer.ethCache.nonce,
                from: transfer.ethCache.from,
                to: transfer.ethCache.to,
                data: transfer.ethCache.data
            };
            const foundTx = await find_replacement_tx_1.findReplacementTx(provider, transfer.ethCache.safeReorgHeight, tx);
            if (!foundTx)
                return transfer;
            approvalReceipt = await provider.getTransactionReceipt(foundTx.hash);
        }
        catch (error) {
            console.error(error);
            if (error instanceof find_replacement_tx_1.TxValidationError) {
                return {
                    ...transfer,
                    errors: [...transfer.errors, error.message],
                    status: status.FAILED
                };
            }
            throw error;
        }
    }
    if (!approvalReceipt)
        return transfer;
    if (!approvalReceipt.status) {
        const error = `Transaction failed: ${approvalReceipt.transactionHash}`;
        return {
            ...transfer,
            approvalReceipts: [...transfer.approvalReceipts, approvalReceipt],
            errors: [...transfer.errors, error],
            status: status.FAILED
        };
    }
    if (approvalReceipt.transactionHash !== approvalHash) {
        // Record the replacement tx approvalHash
        transfer = {
            ...transfer,
            approvalHashes: [...transfer.approvalHashes, approvalReceipt.transactionHash]
        };
    }
    return {
        ...transfer,
        approvalReceipts: [...transfer.approvalReceipts, approvalReceipt],
        completedStep: APPROVE,
        status: status.ACTION_NEEDED
    };
}
exports.checkApprove = checkApprove;
/**
 * Initiate "lock" transaction.
 * Only wait for transaction to have dependable transactionHash created. Avoid
 * blocking to wait for transaction to be mined. Status of transactionHash
 * being mined is then checked in checkStatus.
 */
async function lock(transfer, options) {
    var _a, _b, _c, _d, _e;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getSignerProvider();
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        // Webapp should prevent the user from confirming if the wrong network is selected
        throw new Error(`Wrong eth network for lock, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const ethTokenLocker = new ethers_1.ethers.Contract((_c = options.erc20LockerAddress) !== null && _c !== void 0 ? _c : bridgeParams.erc20LockerAddress, (_d = options.erc20LockerAbi) !== null && _d !== void 0 ? _d : bridgeParams.erc20LockerAbi, (_e = options.signer) !== null && _e !== void 0 ? _e : provider.getSigner());
    // If this tx is dropped and replaced, lower the search boundary
    // in case there was a reorg.
    const safeReorgHeight = await provider.getBlockNumber() - 20;
    const pendingLockTx = await ethTokenLocker.lockToken(transfer.sourceToken, transfer.amount, transfer.recipient);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        ethCache: {
            from: pendingLockTx.from,
            to: pendingLockTx.to,
            safeReorgHeight,
            data: pendingLockTx.data,
            nonce: pendingLockTx.nonce
        },
        lockHashes: [...transfer.lockHashes, pendingLockTx.hash]
    };
}
exports.lock = lock;
async function checkLock(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const lockHash = last(transfer.lockHashes);
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkLock, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    let lockReceipt = await provider.getTransactionReceipt(lockHash);
    // If no receipt, check that the transaction hasn't been replaced (speedup or canceled)
    if (!lockReceipt) {
        // don't break old transfers in case they were made before this functionality is released
        if (!transfer.ethCache)
            return transfer;
        try {
            const tx = {
                nonce: transfer.ethCache.nonce,
                from: transfer.ethCache.from,
                to: transfer.ethCache.to,
                data: transfer.ethCache.data
            };
            const foundTx = await find_replacement_tx_1.findReplacementTx(provider, transfer.ethCache.safeReorgHeight, tx);
            if (!foundTx)
                return transfer;
            lockReceipt = await provider.getTransactionReceipt(foundTx.hash);
        }
        catch (error) {
            console.error(error);
            if (error instanceof find_replacement_tx_1.TxValidationError) {
                return {
                    ...transfer,
                    errors: [...transfer.errors, error.message],
                    status: status.FAILED
                };
            }
            throw error;
        }
    }
    if (!lockReceipt)
        return transfer;
    if (!lockReceipt.status) {
        const error = `Transaction failed: ${lockReceipt.transactionHash}`;
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, error],
            lockReceipts: [...transfer.lockReceipts, lockReceipt]
        };
    }
    if (lockReceipt.transactionHash !== lockHash) {
        // Record the replacement tx lockHash
        transfer = {
            ...transfer,
            lockHashes: [...transfer.lockHashes, lockReceipt.transactionHash]
        };
    }
    const txBlock = await provider.getBlock(lockReceipt.blockHash);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        completedStep: LOCK,
        startTime: new Date(txBlock.timestamp * 1000).toISOString(),
        lockReceipts: [...transfer.lockReceipts, lockReceipt]
    };
}
exports.checkLock = checkLock;
async function checkSync(transfer, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (typeof transfer === 'string') {
        return await recover(transfer, options);
    }
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const nearAccount = (_b = options.nearAccount) !== null && _b !== void 0 ? _b : await utils_1.getNearAccount();
    if (!transfer.checkSyncInterval) {
        // checkSync every 20s: reasonable value to show the confirmation counter x/30
        transfer = {
            ...transfer,
            checkSyncInterval: (_c = options.sendToNearSyncInterval) !== null && _c !== void 0 ? _c : bridgeParams.sendToNearSyncInterval
        };
    }
    if (transfer.nextCheckSyncTimestamp && new Date() < new Date(transfer.nextCheckSyncTimestamp)) {
        return transfer;
    }
    const lockReceipt = last(transfer.lockReceipts);
    const eventEmittedAt = lockReceipt.blockNumber;
    const syncedTo = await utils_2.ethOnNearSyncHeight((_d = options.nearClientAccount) !== null && _d !== void 0 ? _d : bridgeParams.nearClientAccount, nearAccount);
    const completedConfirmations = Math.max(0, syncedTo - eventEmittedAt);
    let proof;
    if (completedConfirmations > transfer.neededConfirmations) {
        // Check if relayer already minted
        proof = await utils_2.findEthProof('Locked', lockReceipt.transactionHash, (_e = options.erc20LockerAddress) !== null && _e !== void 0 ? _e : bridgeParams.erc20LockerAddress, (_f = options.erc20LockerAbi) !== null && _f !== void 0 ? _f : bridgeParams.erc20LockerAbi, provider);
        const proofAlreadyUsed = await nearAccount.viewFunction((_g = options.nep141Factory) !== null && _g !== void 0 ? _g : bridgeParams.nep141Factory, 'is_used_proof', Buffer.from(proof), { stringify: (args) => args });
        if (proofAlreadyUsed) {
            if (options.callIndexer) {
                try {
                    const { transactions, timestamps } = await utils_2.findFinalizationTxOnNear({
                        proof: Buffer.from(proof).toString('base64'),
                        connectorAccount: (_h = options.nep141Factory) !== null && _h !== void 0 ? _h : bridgeParams.nep141Factory,
                        eventRelayerAccount: (_j = options.eventRelayerAccount) !== null && _j !== void 0 ? _j : bridgeParams.eventRelayerAccount,
                        finalizationMethod: 'deposit',
                        callIndexer: options.callIndexer
                    });
                    let finishTime;
                    if (timestamps.length > 0) {
                        finishTime = new Date(timestamps[0] / 10 ** 6).toISOString();
                    }
                    transfer = {
                        ...transfer,
                        finishTime,
                        mintHashes: [...transfer.mintHashes, ...transactions]
                    };
                }
                catch (error) {
                    // Not finding the finalization tx should not prevent processing/recovering the transfer.
                    console.error(error);
                }
            }
            return {
                ...transfer,
                completedStep: MINT,
                completedConfirmations,
                status: status.COMPLETE,
                errors: [...transfer.errors, 'Transfer already finalized.']
            };
        }
    }
    const nearEventRelayerMargin = (_k = options.nearEventRelayerMargin) !== null && _k !== void 0 ? _k : bridgeParams.nearEventRelayerMargin;
    if (completedConfirmations < transfer.neededConfirmations + nearEventRelayerMargin) {
        // Leave some time for the relayer to finalize
        return {
            ...transfer,
            nextCheckSyncTimestamp: new Date(Date.now() + transfer.checkSyncInterval),
            completedConfirmations,
            status: status.IN_PROGRESS
        };
    }
    return {
        ...transfer,
        completedConfirmations,
        completedStep: SYNC,
        status: status.ACTION_NEEDED,
        proof // used when checkSync() is called by mint()
    };
}
exports.checkSync = checkSync;
/**
 * Mint NEP141 tokens to transfer.recipient. Causes a redirect to NEAR Wallet,
 * currently dealt with using URL params.
 */
async function mint(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_1.getNearAccount();
    // Check if the transfer is finalized and get the proof if not
    transfer = await checkSync(transfer, options);
    if (transfer.status !== status.ACTION_NEEDED)
        return transfer;
    const proof = transfer.proof;
    // NOTE:
    // checkStatus should wait for NEAR wallet redirect if it didn't happen yet.
    // On page load the dapp should clear urlParams if transactionHashes or errorCode are not present:
    // this will allow checkStatus to handle the transfer as failed because the NEAR transaction could not be processed.
    if (typeof window !== 'undefined')
        utils_2.urlParams.set({ minting: transfer.id });
    if (typeof window !== 'undefined')
        transfer = await client_1.track({ ...transfer, status: status.IN_PROGRESS });
    const tx = await nearAccount.functionCall({
        contractId: (_b = options.nep141Factory) !== null && _b !== void 0 ? _b : bridgeParams.nep141Factory,
        methodName: 'deposit',
        args: proof,
        // 200Tgas: enough for execution, not too much so that a 2fa tx is within 300Tgas
        gas: new bn_js_1.default('200' + '0'.repeat(12)),
        // We need to attach tokens because minting increases the contract state, by <600 bytes, which
        // requires an additional 0.06 NEAR to be deposited to the account for state staking.
        // Note technically 0.0537 NEAR should be enough, but we round it up to stay on the safe side.
        attachedDeposit: new bn_js_1.default('100000000000000000000').mul(new bn_js_1.default('600'))
    });
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        mintHashes: [...transfer.mintHashes, tx.transaction.hash]
    };
}
exports.mint = mint;
/**
 * Process a broadcasted mint transaction
 * checkMint is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkMint can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
async function checkMint(transfer, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const id = utils_2.urlParams.get('minting');
    // NOTE: when a single tx is executed, transactionHashes is equal to that hash
    const txHash = utils_2.urlParams.get('transactionHashes');
    const errorCode = utils_2.urlParams.get('errorCode');
    const clearParams = ['minting', 'transactionHashes', 'errorCode', 'errorMessage'];
    if (!id) {
        // The user closed the tab and never rejected or approved the tx from Near wallet.
        // This doesn't protect agains the user broadcasting a tx and closing the tab before
        // redirect. So the dapp has no way of knowing the status of that transaction.
        // Set status to FAILED so that it can be retried
        const newError = `A finalization transaction was initiated but could not be verified.
      Click 'Retry' to make sure the transfer is finalized.`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (id !== transfer.id) {
        // Another minting transaction cannot be in progress, ie if checkMint is called on
        // an in progess mint then the transfer ids must be equal or the url callback is invalid.
        const newError = `Couldn't determine transaction outcome.
      Got transfer id '${id} in URL, expected '${transfer.id}`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (errorCode) {
        // If errorCode, then the redirect succeded but the tx was rejected/failed
        // so clear url params
        utils_2.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: ' + errorCode;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (!txHash) {
        // If checkMint is called before mint sig wallet redirect,
        // log the error but don't mark as FAILED and don't clear url params
        // as the wallet redirect has not happened yet
        const newError = 'Tx hash not received: pending redirect or wallet error';
        console.log(newError);
        return transfer;
    }
    if (txHash.includes(',')) {
        utils_2.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: expected single txHash, got: ' + txHash;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    const decodedTxHash = near_api_js_1.utils.serialize.base_decode(txHash);
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_1.getNearAccount();
    const mintTx = await nearAccount.connection.provider.txStatus(decodedTxHash, nearAccount.accountId);
    // @ts-expect-error : wallet returns errorCode
    if (mintTx.status.Unknown) {
        // Transaction or receipt not processed yet
        return transfer;
    }
    // Check status of tx broadcasted by wallet
    // @ts-expect-error : wallet returns errorCode
    if (mintTx.status.Failure) {
        utils_2.urlParams.clear(...clearParams);
        const error = `NEAR transaction failed: ${txHash}`;
        console.error(error);
        return {
            ...transfer,
            errors: [...transfer.errors, error],
            status: status.FAILED,
            mintHashes: [...transfer.mintHashes, txHash]
        };
    }
    // Clear urlParams at the end so that if the provider connection throws,
    // checkStatus will be able to process it again in the next loop.
    utils_2.urlParams.clear(...clearParams);
    return {
        ...transfer,
        completedStep: MINT,
        status: status.COMPLETE,
        mintHashes: [...transfer.mintHashes, txHash]
    };
}
exports.checkMint = checkMint;
const last = (arr) => arr[arr.length - 1];
//# sourceMappingURL=index.js.map