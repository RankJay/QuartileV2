import { ethers } from 'ethers';
import { Account } from 'near-api-js';
import { TransferStatus, TransactionInfo } from '@near-eth/client/dist/types';
export declare const SOURCE_NETWORK = "ethereum";
export declare const DESTINATION_NETWORK = "near";
export declare const TRANSFER_TYPE = "@near-eth/nep141-erc20/natural-erc20/sendToNear";
export interface TransferDraft extends TransferStatus {
    type: string;
    lockHashes: string[];
    lockReceipts: ethers.providers.TransactionReceipt[];
    mintHashes: string[];
    completedConfirmations: number;
    neededConfirmations: number;
}
export interface ApprovalInfo extends TransactionInfo, TransferStatus {
    approvalHashes: string[];
    approvalReceipts: ethers.providers.TransactionReceipt[];
}
export interface Transfer extends TransferDraft, TransactionInfo {
    id: string;
    startTime: string;
    finishTime?: string;
    decimals: number;
    destinationTokenName: string;
    recipient: string;
    sender: string;
    symbol: string;
    sourceTokenName: string;
    checkSyncInterval?: number;
    nextCheckSyncTimestamp?: Date;
    proof?: Uint8Array;
}
export interface TransferOptions {
    provider?: ethers.providers.JsonRpcProvider;
    erc20LockerAddress?: string;
    erc20LockerAbi?: string;
    erc20Abi?: string;
    sendToNearSyncInterval?: number;
    nep141Factory?: string;
    nearEventRelayerMargin?: number;
    nearAccount?: Account;
    nearClientAccount?: string;
    callIndexer?: (query: string) => Promise<Array<{
        originated_from_transaction_hash: string;
        included_in_block_timestamp: string;
    }>>;
    eventRelayerAccount?: string;
}
export declare const i18n: {
    en_US: {
        steps: (transfer: Transfer) => import("@near-eth/client/dist/types").Step[];
        statusMessage: (transfer: Transfer) => string;
        callToAction: (transfer: Transfer) => "Retry" | "Transfer" | "Deposit" | null;
    };
};
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
export declare function act(transfer: Transfer): Promise<Transfer>;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
export declare function checkStatus(transfer: Transfer): Promise<Transfer>;
/**
 * Find all lock transactions sending `erc20Address` tokens to NEAR.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.erc20Address Token address.
 * @param params.options Optional arguments.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.erc20LockerAddress Rainbow bridge ERC-20 token locker address.
 * @param params.options.erc20LockerAbi Rainbow bridge ERC-20 token locker abi.
 * @returns Array of Ethereum transaction hashes.
 */
export declare function findAllTransactions({ fromBlock, toBlock, sender, erc20Address, options }: {
    fromBlock: number | string;
    toBlock: number | string;
    sender: string;
    erc20Address: string;
    options?: {
        provider?: ethers.providers.Provider;
        erc20LockerAddress?: string;
        erc20LockerAbi?: string;
    };
}): Promise<string[]>;
/**
 * Recover all transfers sending `erc20Address` tokens to Near.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.erc20Address Token address.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
export declare function findAllTransfers({ fromBlock, toBlock, sender, erc20Address, options }: {
    fromBlock: number | string;
    toBlock: number | string;
    sender: string;
    erc20Address: string;
    options?: TransferOptions & {
        decimals?: number;
        symbol?: string;
    };
}): Promise<Transfer[]>;
/**
 * Recover transfer from a lock tx hash.
 * @param lockTxHash Ethereum transaction hash which initiated the transfer.
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
export declare function recover(lockTxHash: string, options?: TransferOptions & {
    decimals?: number;
    symbol?: string;
}): Promise<Transfer>;
/**
 * Initiate a transfer from Ethereum to NEAR by locking tokens.
 * Broadcasts the lock transaction and creates a transfer object.
 * The receipt will be fetched by checkStatus.
 * Allowance must be enough before tokens can be transfered.
 * Use `approve` to allow spending of ERC-20 tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.erc20Address ERC-20 address of token to transfer.
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient NEAR address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.symbol ERC-20 symbol (queried if not provided).
 * @param params.options.decimals ERC-20 decimals (queried if not provided).
 * @param params.options.sender Sender of tokens (defaults to the connected wallet address).
 * @param params.options.ethChainId Ethereum chain id of the bridge.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.erc20LockerAddress Rainbow bridge ERC-20 token locker address.
 * @param params.options.erc20LockerAbi Rainbow bridge ERC-20 token locker abi.
 * @param params.options.erc20Abi ERC-20 token abi.
 * @param params.options.signer Ethers signer to use.
 * @returns The created transfer object.
 */
export declare function initiate({ erc20Address, amount, recipient, options }: {
    erc20Address: string;
    amount: string | ethers.BigNumber;
    recipient: string;
    options?: {
        symbol?: string;
        decimals?: number;
        sender?: string;
        ethChainId?: number;
        provider?: ethers.providers.JsonRpcProvider;
        erc20LockerAddress?: string;
        erc20LockerAbi?: string;
        erc20Abi?: string;
        signer?: ethers.Signer;
    };
}): Promise<Transfer>;
/**
 * Allow the bridge ERC-20 locker to transfer tokens from the user's address.
 * Allowance must be enough before tokens can be transfered with `initiate`
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.erc20Address ERC-20 address of token to transfer.
 * @param params.amount Number of tokens to transfer.
 * @param params.options Optional arguments.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.ethChainId Ethereum chain id of the bridge.
 * @param params.options.erc20LockerAddress Rainbow bridge ERC-20 token locker address.
 * @param params.options.erc20Abi ERC-20 token abi.
 * @returns ApprovalInfo object which is used by checkApprove to track the transaction.
 */
export declare function approve({ erc20Address, amount, options }: {
    erc20Address: string;
    amount: string | ethers.BigNumber;
    options?: {
        provider?: ethers.providers.JsonRpcProvider;
        ethChainId?: number;
        erc20LockerAddress?: string;
        erc20Abi?: string;
        signer?: ethers.Signer;
    };
}): Promise<ApprovalInfo>;
/**
 * Check the status of the `approve` transaction.
 * @param transfer Object returned by `approve` to check it's status
 * @param param.options Optional arguments.
 * @param param.options.provider Ethereum provider to use.
 * @param param.options.ethChainId Ethereum chain id of the bridge.
 */
export declare function checkApprove(transfer: ApprovalInfo, options?: {
    provider?: ethers.providers.Provider;
    ethChainId?: number;
}): Promise<ApprovalInfo>;
/**
 * Initiate "lock" transaction.
 * Only wait for transaction to have dependable transactionHash created. Avoid
 * blocking to wait for transaction to be mined. Status of transactionHash
 * being mined is then checked in checkStatus.
 */
export declare function lock(transfer: Transfer, options?: {
    provider?: ethers.providers.JsonRpcProvider;
    ethChainId?: number;
    erc20LockerAddress?: string;
    erc20LockerAbi?: string;
    signer?: ethers.Signer;
}): Promise<Transfer>;
export declare function checkLock(transfer: Transfer, options?: {
    provider?: ethers.providers.Provider;
    ethChainId?: number;
}): Promise<Transfer>;
export declare function checkSync(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Mint NEP141 tokens to transfer.recipient. Causes a redirect to NEAR Wallet,
 * currently dealt with using URL params.
 */
export declare function mint(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Process a broadcasted mint transaction
 * checkMint is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkMint can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
export declare function checkMint(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
//# sourceMappingURL=index.d.ts.map