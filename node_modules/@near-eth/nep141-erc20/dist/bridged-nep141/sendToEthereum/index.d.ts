import { ethers } from 'ethers';
import { Account } from 'near-api-js';
import { FinalExecutionOutcome } from 'near-api-js/lib/providers';
import { TransferStatus, TransactionInfo } from '@near-eth/client/dist/types';
export declare const SOURCE_NETWORK = "near";
export declare const DESTINATION_NETWORK = "ethereum";
export declare const TRANSFER_TYPE = "@near-eth/nep141-erc20/bridged-nep141/sendToEthereum";
export interface TransferDraft extends TransferStatus {
    type: string;
    finalityBlockHeights: number[];
    nearOnEthClientBlockHeight: null | number;
    unlockHashes: string[];
    unlockReceipts: ethers.providers.TransactionReceipt[];
    withdrawHashes: string[];
    withdrawReceiptBlockHeights: number[];
    withdrawReceiptIds: string[];
}
export interface Transfer extends TransferDraft, TransactionInfo {
    id: string;
    startTime: string;
    finishTime?: string;
    decimals: number;
    destinationTokenName: string;
    recipient: string;
    sender: string;
    symbol: string;
    sourceTokenName: string;
    checkSyncInterval?: number;
    nextCheckSyncTimestamp?: Date;
    proof?: Uint8Array;
}
export interface TransferOptions {
    provider?: ethers.providers.Provider;
    erc20LockerAddress?: string;
    sendToEthereumSyncInterval?: number;
    ethChainId?: number;
    nearAccount?: Account;
    ethClientAddress?: string;
    ethClientAbi?: string;
    erc20Abi?: string;
    nep141Factory?: string;
    erc20LockerAbi?: string;
}
export declare const i18n: {
    en_US: {
        steps: (transfer: Transfer) => import("@near-eth/client/dist/types").Step[];
        statusMessage: (transfer: Transfer) => "Failed" | "Ready to transfer from NEAR" | "Ready to deposit in Ethereum" | "Transfering from NEAR" | "Confirming transfer" | "Depositing in Ethereum" | "Transfer complete";
        callToAction: (transfer: Transfer) => "Retry" | "Transfer" | "Deposit" | null;
    };
};
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
export declare function act(transfer: Transfer): Promise<Transfer>;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
export declare function checkStatus(transfer: Transfer): Promise<Transfer>;
/**
 * Find all withdraw (burn) transactions sending nep141Address tokens from NEAR to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.erc20Address Token address on Ethereum.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options Optional arguments.
 * @param params.options.nep141Factory ERC-20 connector factory to determine the NEAR address.
 * @param params.options.nep141Address Token address on NEAR.
 * @returns Array of NEAR transaction hashes.
 */
export declare function findAllTransactions({ fromBlock, toBlock, sender, erc20Address, callIndexer, options }: {
    fromBlock: string;
    toBlock: string;
    sender: string;
    erc20Address: string;
    callIndexer: (query: string) => Promise<[{
        originated_from_transaction_hash: string;
        args: {
            method_name: string;
        };
    }]>;
    options?: {
        nep141Factory?: string;
        nep141Address?: string;
    };
}): Promise<string[]>;
/**
 * Recover all transfers sending nep141Address tokens from NEAR to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.erc20Address Token address on Ethereum.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
export declare function findAllTransfers({ fromBlock, toBlock, sender, erc20Address, callIndexer, options }: {
    fromBlock: string;
    toBlock: string;
    sender: string;
    erc20Address: string;
    callIndexer: (query: string) => Promise<[{
        originated_from_transaction_hash: string;
        args: {
            method_name: string;
        };
    }]>;
    options?: TransferOptions & {
        decimals?: number;
        symbol?: string;
    };
}): Promise<Transfer[]>;
/**
 * Recover transfer from a withdraw tx hash
 * @param withdrawTxHash Near tx hash containing the token withdrawal
 * @param sender Near account sender of withdrawTxHash
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
export declare function recover(withdrawTxHash: string, sender?: string, options?: TransferOptions & {
    decimals?: number;
    symbol?: string;
}): Promise<Transfer>;
/**
 * Parse the withdraw receipt id and block height needed to complete
 * the step WITHDRAW
 * @param withdrawTx
 * @param sender
 * @param sourceToken
 * @param nearAccount
 */
export declare function parseWithdrawReceipt(withdrawTx: FinalExecutionOutcome, sender: string, sourceToken: string, nearAccount: Account): Promise<{
    id: string;
    blockHeight: number;
}>;
/**
 * Initiate a transfer from NEAR to Ethereum by burning minted tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.erc20Address ERC-20 address of the bridged token to transfer.
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient Ethereum address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.symbol ERC-20 symbol (queried if not provided).
 * @param params.options.decimals ERC-20 decimals (queried if not provided).
 * @param params.options.sender Sender of tokens (defaults to the connected NEAR wallet address).
 * @param params.options.nearAccount Connected NEAR wallet account to use.
 * @param params.options.nep141Address params.erc20Address's address on NEAR.
 * @param params.options.erc20Abi Standard ERC-20 ABI.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.nep141Factory ERC-20 connector factory to determine the NEAR address.
 * @returns The created transfer object.
 */
export declare function initiate({ erc20Address, amount, recipient, options }: {
    erc20Address: string;
    amount: string | ethers.BigNumber;
    recipient: string;
    options?: {
        symbol?: string;
        decimals?: number;
        sender?: string;
        nearAccount?: Account;
        nep141Address?: string;
        erc20Abi?: string;
        provider?: ethers.providers.Provider;
        nep141Factory?: string;
    };
}): Promise<Transfer>;
export declare function withdraw(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Process a broadcasted withdraw transaction
 * checkWithdraw is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkWithdraw can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
export declare function checkWithdraw(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Wait for a final block with a strictly greater height than withdrawTx
 * receipt. This block (or one of its ancestors) should hold the outcome.
 * Although this may not support sharding.
 * TODO: support sharding
 */
export declare function checkFinality(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Wait for the block with the given receipt/transaction in Near2EthClient, and
 * get the outcome proof only use block merkle root that we know is available
 * on the Near2EthClient.
 */
export declare function checkSync(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Check if a NEAR outcome receipt_id has already been used to finalize a transfer to Ethereum.
 */
export declare function proofAlreadyUsed(provider: ethers.providers.Provider, proof: any, erc20LockerAddress: string, erc20LockerAbi: string): Promise<boolean>;
/**
 * Unlock tokens stored in the contract at process.env.ethLockerAddress,
 * passing the proof that the tokens were withdrawn/burned in the corresponding
 * NEAR BridgeToken contract.
 */
export declare function unlock(transfer: Transfer | string, options?: Omit<TransferOptions, 'provider'> & {
    provider?: ethers.providers.JsonRpcProvider;
    signer?: ethers.Signer;
}): Promise<Transfer>;
export declare function checkUnlock(transfer: Transfer, options?: {
    provider?: ethers.providers.Provider;
    ethChainId?: number;
}): Promise<Transfer>;
//# sourceMappingURL=index.d.ts.map